==> 1 - Introduction.md <==
# Introduction

A Halogen application consists of a tree of components. Each component is a self contained unit that has its own state, and re-renders when the state changes.

A component's state is changed by the component evaluating inputs known as queries, or by evaluating actions which arise "internally" from the component's rendered HTML.

Each component defines five types which govern how it operates:

1. `State` - the value which will drive the behaviour and appearance of the component.

2. `Query` - the external messages which may be sent to the component. We use the term "query" as queries are not just instructions to the component, they can also be used to request information from the component.

3. `Action` - the events that arise internally to the component. Typically, these arise from user interaction, such as a button click.

4. `Message` - the outbound messages that a child component can send to their parent. Output messages are used to notify external listeners of activity within the component, allowing a parent component to observe activity within a child component.

5. `Input` - inputs provided to the component directly from its parent or the mount point for a root component.

Component definitions are pure. Running the root component to actually produce the UI is the place effects occur. As UIs tend to be asynchronous, this generally means running in the `Aff` monad.

Halogen's types do allow for more than just HTML based UIs, but the guide will focus on this primary HTML use case.

Let's take a look at a [defining a component](2%20-%20Defining%20a%20component.md).

==> 2 - Defining a component.md <==
# Defining a component


Here's a somewhat contrived example of a Halogen component:

A runnable version of this is available in the [`basic` example](../examples/basic/).

``` purescript
module Example.Basic.Button (component) where

import Prelude

import Data.Maybe (Maybe(..))
import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP

type State = { enabled :: Boolean }

data Action = Toggle

component :: forall q i o m. H.Component HH.HTML q i o m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }

initialState :: forall i. i -> State
initialState _ = { enabled: false }

render :: forall m. State -> H.ComponentHTML Action () m
render state =
  let
    label = if state.enabled then "On" else "Off"
  in
    HH.button
      [ HP.title label
      , HE.onClick \_ -> Just Toggle
      ]
      [ HH.text label ]

handleAction ∷ forall o m. Action → H.HalogenM State Action () o m Unit
handleAction = case _ of
  Toggle ->
    H.modify_ \st -> st { enabled = not st.enabled }
```
A runnable version of this is available in the [`basic` example](../examples/basic/).

This is a component for a button that displays its current state as the label, and is toggled when clicked by a user. The rest of this chapter will break down the elements involved here.

## Halogen `Component`

The `Component` type combines all of the state management and rendering information for a given component. Over this and the coming sections, we will examine it's type signature and how to use it effectively. The `Component` type wraps another type used for evaluation called [`HalogenM`][Halogen.Query.HalogenM.HalogenM].

``` purescript
component :: forall q i o m. H.Component HH.HTML q i o m
```

Let's examine each part of this type for clarity:

- `H.Component` - this is the constructor for our component type
- `HH.HTML` - this defines the surface type we will be rendering to, this could include any number of rendering structures, though the most common is HTML.
- `q` - the type of _queries_ to this component.
- `i` - the type of _input_ to this component, this would be a value received from the parent or from a mounting function.
- `o` - the type of output messages generated by this component, this would be a value sent to a parent component.
- `m` - the underlying monad that this component uses for evaluation, by default this uses HalogenM, which has no effect capabilities on its own, However you can easily constrain `m` to be a monad with `MonadAff` and/or `MonadEffect` typeclass instances. (such as `Effect`, `Aff`, or a monad transformer of your choice), this will require the `hoist` function, which we will discuss in a later section.

The component is constructed using the `mkComponent` function, which takes a record used to describe relevant values and functions used for the components operation.

The record `mkComponent` takes must include an `initialState` row, which is a function of type `Input -> State` (both `Input` and `State` are types you will define locally in your component module, or types you will substitute with `Unit`, for example this component accepts no input). If the component will initialize with a predefined state, such as in our case (`{ enabled: False }`), the initialState function will be `const { enabled: False}`, or a function equivalent to it as seen above.

The next row in the argument to `mkComponent` will be `render`, which tells the component how to render for a given state,  this is a pure function from state to a rendered structure, and does not perform any side effects directly, the rendering itself will be handled by Halogen.

The final row in the argument to `mkComponent` is `eval`, eval will be covered in depth over the coming sections, but in short, all effectful action occurs in the functions provided to eval (`eval` itself is a record type with functions for handling _actions_, _input_, _queries_, and lifecycle-related effects).  lifecycle will be covered in a later chapter.

`Component` gives us the ability to perform actions during the evaluation of input, queries, lifecycle, and actions. The most obvious of these is the ability to manipulate the state of a component. There's a [`MonadState`][Control.Monad.State.Class.MonadState] instance that allows us to do these:

- [`get`][Control.Monad.State.Class.get] retrieves the current state value
- [`gets f`][Control.Monad.State.Class.gets] retrieves the state value and applies `f` - generally used to extract a part of the state (for example, `gets _.someProp` when using a record state).
- [`modify_ f`][Control.Monad.State.Class.modify_] updates the stored state value by applying `f` to it.
- [`put`][Control.Monad.State.Class.put] overwrites the entire current state value. Be careful with this!

Halogen re-exports these functions from the main `Halogen` module for convenience.

There are a range of other useful instances for `HalogenM`, but we'll cover those elsewhere in the guide.

## State

For this button component, we just need a simple state type: is the button on or off?

```purescript
type State = { enabled :: Boolean }
```
We could easily adjust this to use a sum type for various button states by using a type such as:

```purescript
data ButtonEnabled = ButtonOn | ButtonOff
type State = { enabled :: ButtonEnabled }
```

The initial value for state is defined with the `initialstate` row provided to `mkComponent`.

It should be noted that while most components will require a record type or ADT for state, it is not strictly necessary and we could very easily make `type State = Bool`.

## Rendering

Now that we know our state, how do we represent that state as rendered output?

``` purescript
render :: forall m. State -> H.ComponentHTML Action () m
```

Looking at the type we can see that the state is the input, and a [`ComponentHTML`][Halogen.Component.ComponentHTML] value is produced. This is a pure function, so no state changes can take place during `render`.

We also supply the _Action_ types that the rendered `ComponentHtml` can raise, and the `ChildSlots` for the component (in this case we have no childSlots, so the parameter is the empty row `()`). Finally, we provide a monad type variable which decribes the monad the render function will run in, by Convention, this will almost always be the type variable `m`.

### The HTML DSL

Halogen provides a HTML DSL (domain specific language) to construct [`ComponentHTML`][Halogen.Component.ComponentHTML] values. The DSL gives us a type-safe way of declaring HTML so that only suitable properties can be applied to each element. The resulting value is not actual HTML, it is a representation that is later applied to the DOM by Halogen.

In the code examples, the `HH` prefix is for elements, `HP` is for properties, and `HE` is for event handlers. These names are the suggested convention to use whenever referring to the [`Halogen.HTML`][Halogen.HTML], [`Halogen.HTML.Properties`][Halogen.HTML.Properties], and [`Halogen.HTML.Events`][Halogen.HTML.Events] modules.

Element functions generally follow this scheme:

```
elementName [ ... properties ... ] [ ... children ... ]
```

There are exceptions such as elements that expect no properties, such as `text`. In the case of `text`, the element only accepts a single `String`. Some other elements accept no children, such as a `br`, or `textarea`. For every element there is also a version that skips the properties array, usable by affixing an underscore to the name ([`button_`][Halogen.HTML.Elements.button_] instead of [`button`][Halogen.HTML.Elements.button]).

As with traditional HTML, event handlers are provided as element properties, and are used to feed action queries back to the component:

``` purescript
  let
    label = if state.enabled then "On" else "Off"
  in
    HH.button
      [ HP.title label
      , HE.onClick \_ -> Just Toggle
      ]
      [ HH.text label ]
```

The above code sample shows a button element which will raise the action `Toggle` when clicked.

The `onClick` function from `Halogen.HTML.Events` will accept any function from an `Event` (found in `Web.Event.Event`) to a `Maybe Action`, if the function returns a `Just`, then the `Action` will be evaluated.

It is common (in order for our component to be interesting), to either set bound variables to be equal to some part of our state (such as `label` above), or to use case matching to render differently based on our state values.

If you wish to build a component that does not need to change its own state, and works more-or-less as a combinator function from a given value to HTML output, take a look at our section on _Custom Elements_.

## Action Types

_Actions_ can be raised within a component to trigger evaluation, causing some change within a component or an effect, they then return the `Unit` value. A constructor for an _action_ will look something like this:

``` purescript
data Action = Toggle
```

The _action_ may carry parameters (such as a form input value, or the HTML event itself, particularly if effects need to be applied to it, such as `preventDefault`), however it is not necessary for any action to carry parameters, as seen here.

### Evaluating actions

Let's look at our Component's `eval` structure:

```purescript
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
```

Here we use the `mkEval` convenience function, and provide it with a modified `defaultEval`, which is a no-op by default.

We've added our own handleAction function, which is where we determine which effects are necessary based upon the _action_ that was raised.

Here's our handleAction:

```purescript
handleAction ∷ forall o m. Action → H.HalogenM State Action () o m Unit
handleAction = case _ of
  Toggle ->
    H.modify_ \st -> st { enabled = not st.enabled }
```

Let's examine the type signature of `handleAction` a little closer.

For this component's `Action` type, we will return a `HalogenM` with this component's state, action, input, output, and underlying monad,  and an underlying value of unit, which is everything Halogen needs in order to render the next state of the component. The only thing that is likely to change in the return value is the `State` value, which we will modify using the state helpers `get`, `gets` `modify` and `put` described above.

So when we receive the `Toggle` action you can see that we call `modify` on our state, and modify it by calling `not`, flipping the boolean and causing a re-render.

Given that we are operating in a monad with state capabilities, so far the evaluation is entirely pure, for effectful evaluation, see our later chapters on random effects and ajax.

Next up, let's take a look at how to create a component that can [do something effectful][handling-effects] other than update its own state.

[Control.Monad.State.Class.get]: https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#v:get "Control.Monad.State.Class.get"
[Control.Monad.State.Class.gets]: https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#v:gets "Control.Monad.State.Class.gets"
[Control.Monad.State.Class.modify_]: https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#v:modify_ "Control.Monad.State.Class.modify_"
[Control.Monad.State.Class.MonadState]: https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#t:MonadState "Control.Monad.State.Class.MonadState"
[Control.Monad.State.Class.put]: https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#v:put "Control.Monad.State.Class.put"
[Data.NaturalTransformation]: https://pursuit.purescript.org/packages/purescript-prelude/4.0.0/docs/Data.NaturalTransformation "Data.NaturalTransformation"
[Data.Void.Void]: https://pursuit.purescript.org/packages/purescript-prelude/4.0.0/docs/Data.Void#t:Void "Data.Void.Void"
[Data.Unit.Unit]: https://pursuit.purescript.org/packages/purescript-prelude/4.0.0/docs/Data.Unit#t:Unit "Data.Unit.Unit"
[Halogen.Component.component-1]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#v:component "Halogen.Component.component"
[Halogen.Component.Component]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#t:Component "Halogen.Component.Component"
[Halogen.Component.ComponentHTML]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#t:ComponentHTML "Halogen.Component.ComponentHTML"
[Halogen.Component.ComponentSpec]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#t:ComponentSpec "Halogen.Component.ComponentSpec"
[Halogen.HTML.Core.HTML]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Core#t:HTML "Halogen.HTML.Core.HTML"
[Halogen.HTML.Elements.button_]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Elements#v:button_ "Halogen.HTML.Elements.button_"
[Halogen.HTML.Elements.button]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Elements#v:button "Halogen.HTML.Elements.button"
[Halogen.HTML.Events.input_]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Events#v:input_ "Halogen.HTML.Events.input_"
[Halogen.HTML.Events.input]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Events#v:input "Halogen.HTML.Events.input"
[Halogen.HTML.Events]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Events "Halogen.HTML.Events"
[Halogen.HTML.Properties]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Properties "Halogen.HTML.Properties"
[Halogen.HTML]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML "Halogen.HTML"
[Halogen.Query.HalogenM.HalogenM]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Query.HalogenM#t:HalogenM "Halogen.Query.HalogenM.HalogenM"
[Halogen.Query.HalogenM.raise]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Query.HalogenM#v:raise "Halogen.Query.HalogenM.raise"

[parent-child-components]: 5%20-%20Parent%20and%20child%20components.md "Parent and child components"
[handling-effects]: 3%20-%20Handling%20effects.md "Handling effects"
[running-components]: 4%20-%20Running%20a%20component.md "Running a component"

==> 3 - Handling effects.md <==
# Handling effects

Halogen components have no built-in mechanisms for dealing with effects during query evaluation. That doesn't mean that they _can't_ have effects, only that there is no implicit mechanism for them. They're made explicit in the usual way: via the type signature.

Let's take another look at the type of the button component from the last chapter:

``` purescript
myButton :: forall m. H.Component HH.HTML Query Input Message m
```

The `m` parameter we left polymorphic here is our means of introducing effect handling into a component `eval` function.

## Using `Effect` during `eval`

Here's a component that generates a random number on demand and displays it to the user:

``` purescript
module Example.Effects.Eff.Random.Component where

import Prelude

import Data.Maybe (Maybe(..), maybe)
import Effect.Class (class MonadEffect)
import Effect.Random (random)
import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Events as HE

data Action = Regenerate

type State = Maybe Number

component :: forall f i o m. MonadEffect m => H.Component HH.HTML f i o m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }

initialState :: forall i. i -> State
initialState _ = Nothing

render :: forall m. State -> H.ComponentHTML Action () m
render state =
  let
    value = maybe "No number generated yet" show state
  in
    HH.div_ $
      [ HH.h1_ [ HH.text "Random number" ]
      , HH.p_ [ HH.text ("Current value: " <> value) ]
      , HH.button
          [ HE.onClick \_ -> Just Regenerate ]
          [ HH.text "Generate new number" ]
      ]

handleAction :: forall o m. MonadEffect m => Action -> H.HalogenM State Action () o m Unit
handleAction = case _ of
  Regenerate -> do
    newNumber <- H.liftEffect random
    H.put (Just newNumber)

```

A runnable version of this is available in the [`effects-eff-random` example](../examples/effects-eff-random/).

To be able to use [`random`][Effect.Random.random], we've constrained `m` to have an instance of `MonadEffect`, so we can now run this component in `Effect`, or `Aff` or any other monad which implements `MonadEffect`.

``` purescript
component :: forall f i o m. MonadEffect m => H.Component HH.HTML f i o m

handleAction :: forall o m. MonadEffect m => Action -> H.HalogenM State Action () o m Unit
```

Why are we using a constraint of `MonadEffect` rather than `Effect` or `Aff`? For convenience - this component is now polymorphic over any monad that supports effects. So our component is easily re-used across multiple applications that might be using different monads to run Halogen. It is possible to [`hoist`][Halogen.Component.hoist] a component, allowing us to change the `m` type, and this polymorphic constraint allows us to keep our options open as our application design changes.

For a detailed explanation of `hoist`, please refer to the chapter on running Halogen components on the DOM.

We can now use the [`liftEffect`][Effect.Class.liftEffect] function in `handleAction`:

``` purescript
handleAction :: forall o m. MonadEffect m => Action -> H.HalogenM State Action () o m Unit
handleAction = case _ of
  Regenerate -> do
    newNumber <- H.liftEffect random
    H.put (Just newNumber)
```

This works as there's a [`MonadEffect`][Effect.Class.MonadEffect] instance for `HalogenM` for any `m` that also has a `MonadEffect` instance.

## Using `Aff` during `eval`

Occasionally it's useful to be able to fetch data from an API, so let's use that for the next example. We're going to make use of the [`affjax`][purescript-affjax] library as it provides a nice `Aff`-based interface for AJAX requests. Our data source will be GitHub's user API.

``` purescript
module Example.Effects.Aff.Ajax.Component where

import Prelude

import Affjax as AX
import Affjax.ResponseFormat as AXRF
import Data.Either (hush)
import Data.Maybe (Maybe(..))
import Effect.Aff.Class (class MonadAff)
import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP
import Web.Event.Event (Event)
import Web.Event.Event as Event

type State =
  { loading :: Boolean
  , username :: String
  , result :: Maybe String
  }

data Action
  = SetUsername String
  | MakeRequest Event

component :: forall f i o m. MonadAff m => H.Component HH.HTML f i o m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }

initialState :: forall i. i -> State
initialState _ = { loading: false, username: "", result: Nothing }

render :: forall m. State -> H.ComponentHTML Action () m
render st =
  HH.form
    [ HE.onSubmit (Just <<< MakeRequest) ]
    [ HH.h1_ [ HH.text "Lookup GitHub user" ]
    , HH.label_
        [ HH.div_ [ HH.text "Enter username:" ]
        , HH.input
            [ HP.value st.username
            , HE.onValueInput (Just <<< SetUsername)
            ]
        ]
    , HH.button
        [ HP.disabled st.loading
        , HP.type_ HP.ButtonSubmit
        ]
        [ HH.text "Fetch info" ]
    , HH.p_
        [ HH.text (if st.loading then "Working..." else "") ]
    , HH.div_
        case st.result of
          Nothing -> []
          Just res ->
            [ HH.h2_
                [ HH.text "Response:" ]
            , HH.pre_
                [ HH.code_ [ HH.text res ] ]
            ]
    ]

handleAction :: forall o m. MonadAff m => Action -> H.HalogenM State Action () o m Unit
handleAction = case _ of
  SetUsername username -> do
    H.modify_ (_ { username = username, result = Nothing :: Maybe String })
  MakeRequest event -> do
    H.liftEffect $ Event.preventDefault event
    username <- H.gets _.username
    H.modify_ (_ { loading = true })
    response <- H.liftAff $ AX.get AXRF.string ("https://api.github.com/users/" <> username)
    H.modify_ (_ { loading = false, result = hush response.body })
```

A runnable version of this is available in the [`effects-aff-ajax` example](../examples/effects-aff-ajax/).

As with the `Effect`-based example, we have constrained our component to use `MonadAff`, which subsumes synchronous effects while permitting asynchronous effects. `HalogenM` also has a [`MonadAff`][Effect.Aff.Class.MonadAff] instance where `m` has a `MonadAff` instance, and so we can now use [`liftAff`][Effect.Aff.Class.liftAff] in our `handleAff`:

``` purescript
  MakeRequest event -> do
    H.liftEffect $ Event.preventDefault event
    username <- H.gets _.username
    H.modify_ (_ { loading = true })
    response <- H.liftAff $ AX.get AXRF.string ("https://api.github.com/users/" <> username)
    H.modify_ (_ { loading = false, result = hush response.body })
```

Note how there was no need to setup callbacks or anything of that nature. Using `liftAff` means we can mix the behaviour of `Aff` with our other component-related operations, giving us seamless async capabilities.

## Mixing `Effect` and `Aff`

Any type that satisfies a `MonadAff` constraint also satisfies `MonadEffect`, so using `Aff` as the base monad for a component allows `liftEffect` and `liftAff` to be used together freely.

Let's take a look at [running a component][running-components] to produce a UI next, where we'll also cover how to mount a component in `Effect` or `Aff`.

[purescript-affjax]: https://pursuit.purescript.org/packages/purescript-affjax "purescript-affjax"

[Effect.Aff.Class.liftAff]: https://pursuit.purescript.org/packages/purescript-aff/4.0.0/docs/Effect.Aff.Class#v:liftAff "Effect.Aff.Class.liftAff"
[Effect.Aff.Class.MonadAff]: https://pursuit.purescript.org/packages/purescript-aff/4.0.0/docs/Effect.Aff.Class#t:MonadAff "Effect.Aff.Class.MonadAff"
[Effect.Class.liftEffect]: https://pursuit.purescript.org/packages/purescript-effect/2.0.0/docs/Effect.Class#v:liftEffect "Effect.Class.liftEffect"
[Effect.Class.MonadEffect]: https://pursuit.purescript.org/packages/purescript-effect/2.0.0/docs/Effect.Class#t:MonadEffect "Effect.Class.MonadEffect"
[Effect.Random.random]: https://pursuit.purescript.org/packages/purescript-random/4.0.0/docs/Effect.Random#v:random "Effect.Random.random"
[Halogen.Component.hoist]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#v:hoist "Halogen.Component.hoist"

[running-components]: 4%20-%20Running%20a%20component.md "Running a component"

==> 4 - Running a component.md <==
# Running a component


So far we've learned how to define a component, and to use `Aff` for effect handling. For this information to be of any use we're going to want to see something in the browser!

Halogen provides a driver for a PureScript implementation of a virtual DOM for efficient patching of the actual DOM. This functionality is provided by the [`Halogen.VDom.Driver`][Halogen.VDom.Driver] module.

The most basic possible `main` function for a Halogen app will look something like this:

``` purescript
module Example.Basic.Main where

import Prelude

import Effect (Effect)
import Example.Basic.Button as Button
import Halogen.Aff as HA
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = HA.runHalogenAff do
  body <- HA.awaitBody
  runUI Button.component unit body
```

This assumes our component is pure, has no meaningful input value, we don't care about any messages it might emit, and have no need to send queries into it.

## `runUI`

The main function involved here is [`runUI`][Halogen.VDom.Driver.runUI]. It takes a component and a reference to a HTML element to use as a container:

``` purescript
runUI
  :: forall query input output
   . Component HTML query input output Aff
  -> input
  -> DOM.HTMLElement
  -> Aff (HalogenIO query output Aff)
```

The `input` argument is the input type for the component - since we're creating the root component here this will never change. We still need to provide a value though, as the component's initial state might be based on it. All the examples we've covered so far don't make use of this, so for those cases we'd be passing `unit`.

The element we pass in should already be present in the DOM, and should be empty. If either of these conditions are not met then strange things may occur - the behaviour is unspecified. We use `awaitBody` to ensure that the `body` element is on the DOM, and to select the element, binding it to a variable.

We expect the component's `m` type variable to be `Aff` at this point, and this is also what `runUI` returns in. The `runHalogenAff` function allows us to launch asynchronous effects from within the `Effect` monad. This is why in the previous chapter the recommendation was made to use `Aff` for components even if you only need `Effect`. If the component is pure, this type will work out since the `m` type should be a type variable and we can substitute `Aff` in. If we have something else in here, then the component will have to be [`hoist`][Halogen.Component.hoist]ed into `Aff`.

The `hoist` function allows us run a component in an alternative monad, here's an example:

``` purescript
main :: Effect Unit
main = HA.runHalogenAff do
  body <- HA.awaitBody
  let
    rootComponent :: H.Component HH.HTML Router.Query {} Void Aff
    rootComponent = H.hoist (runAppM environment) Router.component
  io <- runUI rootComponent {} body

```

In this case, we have created an `AppM` custom monad for the application which is a common architecture. The `AppM` monad might be something like a newtype over `ReaderT Aff`, or perhaps some other effect system. However, since the default behaviour is to run in `Effect`, the `hoist` function is used to run our component tree in whatever context we require.

The last thing to look at here is the resulting `HalogenIO` value. It's a record that gives us some options for communicating with the component we just ran:

``` purescript
type HalogenIO f o m =
  { query :: forall a. query a -> m (Maybe a)
  , subscribe :: Consumer o m Unit -> m Unit
  , dispose :: m Unit
  }
```

Note that `m` is polymorphic in the synonym. It's populated with `Aff` once again for our case.

- `query` allows us to send queries into the component, using its query algebra (`f`). This is useful for things like [routing][example-driver-routing], or driving an app from an external source - [WebSockets][example-driver-websockets], for example.
- `subscribe` allows us to receive the messages the component emits by providing a [`coroutine`][purescript-coroutines] `Consumer`.

- `dispose` allows us to unmount our component tree.

## Output and Subscribers

If we go back to our basic button example from [chapter 2][defining-components], we can adjust our component to accept input and output as below:

``` purescript
module Example.Driver.IO.Button where

import Prelude

import Data.Maybe (Maybe(..))
import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP

type Slot = H.Slot Query Message

data Query a
  = IsOn (Boolean -> a)
  | SetState Boolean a

data Message = Toggled Boolean

data Action = Toggle

type State = { enabled :: Boolean }

component :: forall i m. H.Component HH.HTML Query i Message m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , handleQuery = handleQuery
        }
    }

initialState :: forall i. i -> State
initialState _ = { enabled: false }

render :: forall m. State -> H.ComponentHTML Action () m
render state =
  let
    label = if state.enabled then "On" else "Off"
  in
    HH.button
      [ HP.title label
      , HE.onClick \_ -> Just Toggle
      ]
      [ HH.text label ]

handleAction :: forall m. Action -> H.HalogenM State Action () Message m Unit
handleAction = case _ of
  Toggle -> do
    newState <- H.modify \st -> st { enabled = not st.enabled }
    H.raise (Toggled newState.enabled)

handleQuery :: forall m a. Query a -> H.HalogenM State Action () Message m (Maybe a)
handleQuery = case _ of
  IsOn k -> do
    enabled <- H.gets _.enabled
    pure (Just (k enabled))
  SetState enabled a -> do
    H.modify_ (_ { enabled = enabled })
    pure (Just a)
```
(a runnable version of this is available at [`Examples.Driver-IO.src.Button.purs`][Examples.Driver-IO.src.Button.purs])

In this version of the button component, we've added the `handleQuery` function, the `Query` type and the `Message` type, and substituted the types accordingly such that we accept queries as input and messages as output. Also note that we have the ability modify state and perform effects within `handleQuery`.

Now in our Main.purs:
```purescript
module Example.Driver.IO.Main where

import Prelude

import Control.Coroutine as CR
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Console (log)
import Example.Driver.IO.Button as B
import Halogen (liftEffect)
import Halogen as H
import Halogen.Aff as HA
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = HA.runHalogenAff do
  body <- HA.awaitBody
  io <- runUI B.component unit body

  io.subscribe $ CR.consumer \(B.Toggled newState) -> do
    liftEffect $ log $ "Button was internally toggled to: " <> show newState
    pure Nothing

  state0 <- io.query $ H.request B.IsOn
  liftEffect $ log $ "The button state is currently: " <> show state0

  void $ io.query $ H.tell (B.SetState true)

  state1 ← io.query $ H.request B.IsOn
  liftEffect $ log $ "The button state is now: " <> show state1
```

Here we're setting up a consumer that will listen to the component forever (as it returns `pure Nothing` - see the docs for [`consumer`][Control.Coroutine.consumer] for an explanation), and immediately toggling the button several times on start up. Checking the browser console should reveal the corresponding logged "Button was toggled" messages.

## `Aff`-based utility functions

Aside from `runUI` we used a couple of other utility functions in our `main`, exported from `Halogen.Aff`:

- [`runHalogenAff`][Halogen.Aff.Util.runHalogenAff] runs a Halogen-produced `Aff` value, turning it into an `Effect` so it can be used as `main` for a PureScript bundle. It's provided as a convenience - there is no special behaviour here that couldn't be implemented with functions provided by [`aff`][purescript-aff].
- [`awaitBody`][Halogen.Aff.Util.awaitBody] fetches the `body` element when the document loads. Since we're in `Aff` we can use this to avoid the need for callbacks. This is used when the entire page is going to be a Halogen app.

There are also two more functions provided for cases where we want to run our Halogen app as just part of the page, rather than embedding it in the `body`:

- [`awaitLoad`][Halogen.Aff.Util.awaitLoad] does what the name suggests - waits for the document to load.
- [`selectElement`][Halogen.Aff.Util.selectElement] is a wrapper around `querySelector` - using this after `awaitLoad` allows targeting of a particular container element on the page, to embed our app within.

Now we know how to build simple components and run them, we can take a look at [embedding child components within a parent][parent-child-components].

[example-driver-routing]: ../examples/driver-routing "Routing example"
[example-driver-websockets]: ../examples/driver-websockets "WebSockets example"
[Examples.Driver-IO.src.Button.purs]: ../examples/driver-io "Driver IO example"
[purescript-aff]: https://pursuit.purescript.org/packages/purescript-aff "purescript-aff"
[purescript-coroutines]: https://pursuit.purescript.org/packages/purescript-coroutines "purescript-coroutines"

[Control.Coroutine.consumer]: https://pursuit.purescript.org/packages/purescript-coroutines/5.0.0/docs/Control.Coroutine#v:consumer "Control.Coroutine.consumer"
[Halogen.Aff.Effects.HalogenEffects]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Aff.Effects#t:HalogenEffects "Halogen.Aff.Effects.HalogenEffects"
[Halogen.Aff.Util.awaitBody]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Aff.Util#v:awaitBody "Halogen.Aff.Util.awaitBody"
[Halogen.Aff.Util.awaitLoad]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Aff.Util#v:awaitLoad "Halogen.Aff.Util.awaitLoad"
[Halogen.Aff.Util.runHalogenAff]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Aff.Util#v:runHalogenAff "Halogen.Aff.Util.runHalogenAff"
[Halogen.Aff.Util.selectElement]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Aff.Util#v:selectElement "Halogen.Aff.Util.selectElement"
[Halogen.Component.hoist]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#v:hoist "Halogen.Component.hoist"
[Halogen.VDom.Driver.runUI]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.VDom.Driver#v:runUI "Halogen.VDom.Driver.runUI"
[Halogen.VDom.Driver]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.VDom.Driver "Halogen.VDom.Driver"

[defining-components]: 2%20-%20Defining%20a%20component.md "Defining a component"
[parent-child-components]: 5%20-%20Parent%20and%20child%20components.md "Parent and child components"

==> 5 - Parent and child components.md <==
# Parent and child components

So far the examples have only concerned a single component, however this will only take us so far before the state and query algebra becomes unmanageable. The answer is to break our app into components that can be composed.

Let's take a look at a component that uses our button component as a child:

``` purescript
module Example.Components.Container (component) where

import Prelude

import Data.Maybe (Maybe(..), maybe)
import Data.Symbol (SProxy(..))
import Example.Components.Button as Button
import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Events as HE

data Action
  = HandleButton Button.Message
  | CheckButtonState

type State =
  { toggleCount :: Int
  , buttonState :: Maybe Boolean
  }

type ChildSlots =
  ( button :: Button.Slot Unit
  )

_button :: SProxy "button"
_button = SProxy

component :: forall q i o m. H.Component HH.HTML q i o m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }

initialState :: forall i. i -> State
initialState _ =
  { toggleCount: 0
  , buttonState: Nothing
  }

render :: forall m. State -> H.ComponentHTML Action ChildSlots m
render state =
  HH.div_
    [ HH.slot _button unit Button.component unit (Just <<< HandleButton)
    , HH.p_
        [ HH.text ("Button has been toggled " <> show state.toggleCount <> " time(s)") ]
    , HH.p_
        [ HH.text
            $ "Last time I checked, the button was: "
            <> (maybe "(not checked yet)" (if _ then "on" else "off") state.buttonState)
            <> ". "
        , HH.button
            [ HE.onClick (\_ -> Just CheckButtonState) ]
            [ HH.text "Check now" ]
        ]
    ]

handleAction ::forall o m. Action -> H.HalogenM State Action ChildSlots o m Unit
handleAction = case _ of
  HandleButton (Button.Toggled _) -> do
    H.modify_ (\st -> st { toggleCount = st.toggleCount + 1 })
  CheckButtonState -> do
    buttonState <- H.query _button unit $ H.request Button.IsOn
    H.modify_ (_ { buttonState = buttonState })
```

A runnable version of this is available in the [`components` example](../examples/components/).

This is a somewhat silly example of a container wrapping a button. It counts how many times the button has been toggled, and when asked it can check whether the button is on or off. In reality the "ask" part of this would be unnecessary as the container could use the message from the button to track the state changes, but doing this gives us an excuse to illustrate a request query.

As you can see, things are much the same as with a standalone component, only there are some new types involved.

## Child Slots

The first new element we see defined for this component is the `ChildSlots` type. We use values of this type as the IDs for child components in the rendered HTML. "Slot", "slot address", "slot id" are all used interchangeably to refer to these values.

We also supply a function which uses `SProxy` to access the button component itself.

## Rendering
The render function for a parent component must define the childSlots type it will be rendering, in contrast, previously we have supplied the empty row `()` in this position:

``` purescript
-- Render in general
state -> s a c m

-- Render for a standalone component
render :: forall m. State -> H.ComponentHTML Action () m

render :: forall m. State -> H.ComponentHTML Action ChildSlots m
```

- `s` is the surface or way that we'll be rendering the component (typically HTML).
- `a` is the action type that can be launched from the rendered component.
- `c` is the child slot address type, (`()` in the case where a component has no children).
- `m` is the effect monad the component will run in (Generally this will be polymorphic).

It may seem a little odd that we have to include `m` here when rendering, since no side effects can occur here. We do need evidence that both parent and child components share the same effect monad type for things to work out though.

When we want to render a child component in the HTML DSL we use the [`slot`][Halogen.HTML.slot] function:

``` purescript
slot
  :: forall query action input output slots m label slot _1
     . Row.Cons label (Slot query output slot) _1 slots
  => IsSymbol label
  => Ord slot
  => SProxy label
  -> slot
  -> Component HTML query input output m
  -> input
  -> (output -> Maybe action)
  -> ComponentHTML action slots m
```

We pass it:

- `SProxy label` - the accessor function that uses `SProxy` to get the desired child component by the string name we have given it in the `ChildSlots` type.
- `slot` - a unique ID or index value used to track the individual components and their relative positions. This is useful when the same component needs to be replicated and displayed multiple times. In cases where the same component is not being rendered as siblings within the component, you can supply `unit` to this parameter.
- `Component HTML query input output m` - the component being rendered.
- `input` - the input value for that component (or `unit`).
- `(output -> Maybe action)` - a handler function for output messages.

So for our example, that was:

``` purescript
HH.slot _button unit Button.component unit (Just <<< HandleButton)
```

We're using:

- the `_button` function value we created using `SProxy`.
- `unit`, since we're only rendering this component once.
- the button component.
- `unit` for the input value (that's all the button component expects).
- a mapping to the `HandleButton` action for our parent component as the message handler.

The handler function takes a message value from the child component and translates it into an action on the parent component. We can filter the messages by using the `Maybe` return type, so if we're not interested in what the child has to say we can just use `const Nothing`. If the child outputs no messages, using `Void` as its message type, we can use [`absurd`][Data.Void.absurd].

Care should be taken to avoid using the same slot address for multiple child components. The resulting behaviour is undefined... but almost certainly won't be good. If duplicate slot values are detected a warning message will be logged in the browser console.

After a component is initialized in a slot, providing a different value for any parameter other than the input value or slot address will have no effect on the child component. Say we were to render the parent using:

``` purescript
HH.slot _button unit Button.component unit (Just <<< HandleButton)
```

And then on the next render:

``` purescript
HH.slot _button unit SomeOtherButton.component unit (Just <<< HandleButton2)
```

The change in component and handler would have **no effect**. The child component that was initialized in that slot will be preserved, and the original handler setup will be used when it emits messages.

Changing the slot address value will cause the original component to be destroyed and a new one will be initialized in its place with a fresh state.

Changing input values will be covered later in this chapter.

## Querying

The `mkEval` function allows you to supply several functions for each of the possible ways to interact with the component, including thee evaluation of actions, initialization, finalization (unmounting the component), receiving new input, and handling queries. Here we will discuss `handleQuery`, which allows the component to evaluate queries.

An excellent reference can be found in the [`router` example](../examples/driver-routing/):

``` purescript
module Example.Driver.Routing.RouteLog where

import Prelude

import Data.Array as A
import Data.Maybe (Maybe(..))
import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Properties as HP

type Slot = H.Slot Query Void

data Query a = ChangeRoute String a

type State = { history :: Array String }

component :: forall i o m. H.Component HH.HTML Query i o m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleQuery = handleQuery }
    }

initialState :: forall i. i -> State
initialState _ = { history: [] }

render :: forall act m. State -> H.ComponentHTML act () m
render state =
  HH.div_
    [ HH.p_ [ HH.text "Change the URL hash or choose an anchor link..." ]
    , HH.ul_
        [ HH.li_ [ HH.a [ HP.href "#link-a" ] [ HH.text "Link A" ] ]
        , HH.li_ [ HH.a [ HP.href "#link-b" ] [ HH.text "Link B" ] ]
        , HH.li_ [ HH.a [ HP.href "#link-c" ] [ HH.text "Link C" ] ]
        ]
    , HH.p_ [ HH.text "...to see it logged below:" ]
    , HH.ol_ $ map (\msg -> HH.li_ [ HH.text msg ]) state.history
    ]

handleQuery :: forall act o m a. Query a -> H.HalogenM State act () o m (Maybe a)
handleQuery = case _ of
  ChangeRoute msg a -> do
    H.modify_ \st -> { history: st.history `A.snoc` msg }
    pure (Just a)
```

Here we have a router component,  it receives a Query whenever the browser route changes - in this case the query is always `ChangeRoute`. However we could also add a query which does not modify the component state, but simply returns the route information. In this way, code outside the component can both modify and retreive the information local to the component.

In this example, the `ChangeRoute` query is called from the `main` function within a continuation, or callback, which then executes when the route changes.

``` purescript
module Example.Driver.Routing.Main where

import Prelude

import Control.Coroutine as CR
import Control.Coroutine.Aff (emit)
import Control.Coroutine.Aff as CRA
import Data.Foldable (traverse_)
import Data.Maybe (Maybe(..))
import Data.String.CodeUnits as Str
import Effect (Effect)
import Effect.Aff (Aff)
import Effect.Class (liftEffect)
import Example.Driver.Routing.RouteLog as RouteLog
import Halogen as H
import Halogen.Aff as HA
import Halogen.VDom.Driver (runUI)
import Web.Event.EventTarget (eventListener, addEventListener) as DOM
import Web.HTML (window) as DOM
import Web.HTML.Event.HashChangeEvent as HCE
import Web.HTML.Event.HashChangeEvent.EventTypes as HCET
import Web.HTML.Window as Window

-- A producer coroutine that emits messages whenever the window emits a
-- `hashchange` event.
hashChangeProducer :: CR.Producer HCE.HashChangeEvent Aff Unit
hashChangeProducer = CRA.produce \emitter -> do
  listener <- DOM.eventListener (traverse_ (emit emitter) <<< HCE.fromEvent)
  liftEffect $
    DOM.window
      >>= Window.toEventTarget
      >>> DOM.addEventListener HCET.hashchange listener false

-- A consumer coroutine that takes the `query` function from our component IO
-- record and sends `ChangeRoute` queries in when it receives inputs from the
-- producer.
hashChangeConsumer
  :: (forall a. RouteLog.Query a -> Aff (Maybe a))
  -> CR.Consumer HCE.HashChangeEvent Aff Unit
hashChangeConsumer query = CR.consumer \event -> do
  let hash = Str.drop 1 $ Str.dropWhile (_ /= '#') $ HCE.newURL event
  void $ query $ H.tell $ RouteLog.ChangeRoute hash
  pure Nothing

main :: Effect Unit
main = HA.runHalogenAff do
  body <- HA.awaitBody
  io <- runUI RouteLog.component unit body

  -- Connecting the consumer to the producer initializes both, adding the event
  -- listener to the window and feeding queries back to our component as events
  -- are received.
  CR.runProcess (hashChangeProducer CR.$$ hashChangeConsumer io.query)
```

Here we're using the Coroutine module to create an event producer and consumer, allowing us to run the query with the `tell` function and the `query` function on the `HalogenIO` record (`io.query`).

Let's examine these functions at a closer level. First, `handleQuery`:

``` purescript
handleQuery :: forall act o m a. Query a -> H.HalogenM State act () o m (Maybe a)
```

`handleQuery` accepts some `Query a`, which refers to the component's Query type. It returns a `HalogenM` with the new `State` value (which may or may not have been modified), along with the other `HalogenM` parameters, the last parameter is `(Maybe a)`, `a` here should always be `unit`, however since we cannot prove that, we leave it as a type variable.

The `tell` function is used to build a query which does not expect a meaningful response, let's examine its type:

``` purescript
type Tell f = Unit -> f Unit

tell :: forall f. Tell f -> f Unit
```

`tell` takes the data constructor of a query type `f` and creates a query.
The query is then passed to the `query` function, which runs the query:

``` purescript
query :: forall a. query a -> m (Maybe a)
```

This function will take a well formed query (assembled by the `tell` function for example), and runs it through the component tree.

In the case of `tell`, we do not expect a meaningful response (we can see in the type that `tell` will hold a `Unit` value). However,  there are other queries which can return meaningful values. The `request` function is used for queries which return useful information:

``` purescript
type Request f a = (a -> a) -> f a

request :: forall f a. Request f a -> f a
```

We can see that request takes a query that takes a function.

Here is an example of a request-style query that might be used in a component:

``` purescript
data Query a = SomeRequest (Boolean -> a)
```

So for request-style queries, the return type is represented by the `a`. To send this request, we might do something like this:

``` purescript
getTickCount :: forall o. H.HalogenIO Query o Aff -> Aff (Maybe Int)
getTickCount app = app.query (H.request GetTickCount)
```


Returning to our simple parent and child example in the [`components` example](../examples/components/), we can also run queries against individual components by ChildSlot using the `query` function available in the `Halogen` module.

In our example we use `query` to check what the current button state is when evaluating `CheckButtonState` for the parent:

``` purescript
CheckButtonState -> do
  buttonState <- H.query _button unit $ H.request Button.IsOn
  H.modify_ (_ { buttonState = buttonState })
```

We can see that here, it takes the `SProxy` function that accesses the correct child component, the slot (in the case where the same component is mounted multiple times this might be an integer), and a well-formed query either using `tell` or `request`.

In this function, we're setting the container component state once we have successfully queried the button component.

As it happens, the `buttonState` we're storing in the container component is `Maybe Boolean`, so we didn't have to do anything before storing it here. Often we'll need to handle the `Maybe` first however. A common pattern is to use the `Foldable` instance of `Maybe`, allowing us to write handlers like:

``` purescript
CheckButtonState next -> do
  H.query ButtonSlot (H.request Button.IsOn) >>= traverse_ \isOn ->
    -- do something with `isOn :: Boolean`
    pure unit
  pure next
```

As well as being able to query children one at a time, we can send a query to all the children of a component at once, using the [`queryAll`][Halogen.Query.queryAll] function:

``` purescript
queryAll
  :: forall state action output m label slots query output' slot a _1
   . Row.Cons label (Slot query output' slot) _1 slots
  => IsSymbol label
  => Ord slot
  => SProxy label
  -> query a
  -> HalogenM state action slots output m (Map slot a)
```

This sends the same query to every child that fits the `Sproxy label`, regardless of the slot, and then gives us the result back as a map where the keys are slot addresses and the values are the query result for that child.

That covers it for basic parent/child setups: the only differences between standalone and parent components are the need to define a slot type and the ability to query children.

## Input values

So far, whenever `input` values have been mentioned, they've been glossed over. Now that we know how to embed a child component within a parent, we can get into it.

Input values are a means of passing values into a child component every time a parent re-renders. It is also possible to do this by querying the children whenever a parent modifies its state, but as the `input` mechanism is declarative, it's less error prone and often more convenient.

First we'll need to set up a component that expects an input:

``` purescript
module Example.Components.Inputs.Display where

import Prelude

import Data.Maybe (Maybe(..))
import Halogen as H
import Halogen.HTML as HH

type Slot p = forall q. H.Slot q Void p

type Input = Int

type State = Int

data Action = HandleInput Int

component :: forall q o m. H.Component HH.HTML q Input o m
component =
  H.mkComponent
    { initialState: identity
    , render
    , eval: H.mkEval $ H.defaultEval
        { handleAction = handleAction
        , receive = Just <<< HandleInput
        }
    }

render :: forall m. State -> H.ComponentHTML Action () m
render state =
  HH.div_
    [ HH.text "My input value is:"
    , HH.strong_ [ HH.text (show state) ]
    ]

handleAction :: forall o m. Action -> H.HalogenM State Action () o m Unit
handleAction = case _ of
  HandleInput n -> do
    oldN <- H.get
    when (oldN /= n) $ H.put n
```

This is a super simple component that just displays whatever value it has received as its input. As you can see, both the `Input` and `State` type synonyms we have here are `Int`. Usually the component would have some additional private state of its own.

The next part that needs providing is the `receive` provided to `mkEval`. This function determines what to do when provided with an input value. It is a `i -> Maybe (action)` mapping, so we can choose to do nothing with some input values if we prefer.

Finally, we evaluate the action raised by the `receive` function, just as we would  any other action.  Since `receive` is triggered on every render the parent component makes, we may want to have some logic either in the `receive` function or in `handleAction` which determines whether any change is necessary.

``` purescript
handleAction :: forall o m. Action -> H.HalogenM State Action () o m Unit
handleAction = case _ of
  HandleInput n -> do
    oldN <- H.get
    when (oldN /= n) $ H.put n
```

We can see in this case we are using `when (oldN /=n)` to determine whether or not to update the state, to avoid unnecessary rendering.

When we use this component in a slot now we can pass through an `Int` value based on the parent component's state and see it reflected in the child.

In the [`components-inputs` example](../examples/components-inputs) that the above code was taken from, the "display component" we defined above is used like this:

``` purescript
type ChildSlots =
  (display :: Display.Slot Int
  )

...

HH.ul_
  [ HH.slot _display 1 Display.component state absurd
  , HH.slot _display 2 Display.component (state * 2) absurd
  , HH.slot _display 3 Display.component (state * 3) absurd
  , HH.slot _display 4 Display.component (state * 10) absurd
  , HH.slot _display 5 Display.component (state * state) absurd
  ]
```

This gives us a variety of displays, each with a different permutation of the parent component's state, and all of which update in tandem with changes in the parent component's state.

## Multiple types of child component

The need for multiple types of child component under a parent arises quite often, so Halogen has some tools to help with that.

By "multiple types", an example would be where we have a component for the top level of an app, and inside that view we'd want a menu bar component, a current page view component, a dialog box component, etc. It's unlikely that all these elements would share the same query algebra, so we need a way of dealing with that.

### Querying

``` purescript
handleAction :: forall o m. Action -> H.HalogenM State Action ChildSlots o m Unit
handleAction = case _ of
  ReadStates -> do
    a <- H.query _a unit (H.request CA.IsOn)
    b <- H.query _b unit (H.request CB.GetCount)
    c <- H.query _c unit (H.request CC.GetValue)
    H.put { a, b, c }
```

Here, we've simply imported the various query algebras, and called them on the A, B, and C components then put the results of those queries into state.

This is vastly simplified over previous versions of Halogen.

This and most of the following code snippets are based on the [`components-multitype` example](../examples/components-multitype/).

### Rendering

Rendering is much the same as before:

``` purescript
render :: forall m. State -> H.ComponentHTML Action ChildSlots m
render state = HH.div_
  [ HH.div
      [ HP.class_ (H.ClassName "box")]
      [ HH.h1_ [ HH.text "Component A" ]
      , HH.slot _a unit CA.component unit absurd
      ]
  , HH.div
      [ HP.class_ (H.ClassName "box")]
      [ HH.h1_ [ HH.text "Component B" ]
      , HH.slot _b unit CB.component unit absurd
      ]
  , HH.div
      [ HP.class_ (H.ClassName "box")]
      [ HH.h1_ [ HH.text "Component C" ]
      , HH.slot _c unit CC.component unit absurd
      ]
  , HH.p_
      [ HH.text "Last observed states:"]
  , HH.ul_
      [ HH.li_ [ HH.text ("Component A: " <> show state.a) ]
      , HH.li_ [ HH.text ("Component B: " <> show state.b) ]
      , HH.li_ [ HH.text ("Component C: " <> show state.c) ]
      ]
  , HH.button
      [ HE.onClick (\_ -> Just ReadStates) ]
      [ HH.text "Check states now" ]
  ]
```


You've made it to the end of the guide, as it stands... happy Halogen-ing!

[purescript-profunctor-lenses]: https://github.com/purescript-contrib/purescript-profunctor-lenses

[Data.Either.Nested]: https://pursuit.purescript.org/packages/purescript-either/4.0.0/docs/Data.Either.Nested "Data.Either.Nested"
[Data.Either.Nested.Either2]: https://pursuit.purescript.org/packages/purescript-either/4.0.0/docs/Data.Either.Nested#t:Either2 "Data.Either.Nested.Either2"
[Data.Functor.Coproduct.Coproduct]: https://pursuit.purescript.org/packages/purescript-functors/3.0.0/docs/Data.Functor.Coproduct#t:Coproduct "Data.Functor.Coproduct.Coproduct"
[Data.Functor.Coproduct.Nested]: https://pursuit.purescript.org/packages/purescript-functors/3.0.0/docs/Data.Functor.Coproduct.Nested "Data.Functor.Coproduct.Nested"
[Data.Functor.Coproduct.Nested.Coproduct2]: https://pursuit.purescript.org/packages/purescript-functors/3.0.0/docs/Data.Functor.Coproduct.Nested#t:Coproduct2 "Data.Functor.Coproduct.Nested.Coproduct2"
[Data.Lens.Prism.prism']: https://pursuit.purescript.org/packages/purescript-profunctor-lenses/3.2.0/docs/Data.Lens.Prism#v:prism' "Data.Lens.Prism.prism'"
[Data.Lens.Types.Prism']: https://pursuit.purescript.org/packages/purescript-profunctor-lenses/3.2.0/docs/Data.Lens.Types#t:Prism' "Data.Lens.Types.Prism'"
[Halogen.Component.ChildPath.ChildPath]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component.ChildPath#t:ChildPath "Halogen.Component.ChildPath.ChildPath"
[Halogen.Component.ChildPath.compose]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component.ChildPath#v:compose "Halogen.Component.ChildPath.compose"
[Halogen.Component.ChildPath.cp1]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component.ChildPath#v:cp1 "Halogen.Component.ChildPath.cp1"
[Halogen.Component.ChildPath.cp10]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component.ChildPath#v:cp10 "Halogen.Component.ChildPath.cp10"
[Halogen.Component.ChildPath.cpL]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component.ChildPath#v:cpL "Halogen.Component.ChildPath.cpL"
[Halogen.Component.ChildPath.cpR]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component.ChildPath#v:cpR "Halogen.Component.ChildPath.cpR"
[Halogen.Component.ChildPath]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component.ChildPath "Halogen.Component.ChildPath"
[Halogen.Component.parentComponent]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#v:parentComponent "Halogen.Component.parentComponent"
[Halogen.Component.ParentDSL]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#t:ParentDSL "Halogen.Component.ParentDSL"
[Halogen.Component.ParentHTML]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#t:ParentHTML "Halogen.Component.ParentHTML"
[Halogen.HTML.slot']: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML#v:slot' "Halogen.HTML.slot'"
[Halogen.HTML.slot]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML#v:slot "Halogen.HTML.slot"
[Halogen.Query.HalogenM]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Query#t:HalogenM "Halogen.Query.HalogenM"
[Halogen.Query.query']: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Query#v:query' "Halogen.Query.query'"
[Halogen.Query.query]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Query#v:query "Halogen.Query.query"
[Halogen.Query.queryAll']: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Query#v:queryAll' "Halogen.Query.queryAll'"
[Halogen.Query.queryAll]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Query#v:queryAll "Halogen.Query.queryAll"
[Data.Void.absurd]: https://pursuit.purescript.org/packages/purescript-prelude/4.0.0/docs/Data.Void#v:absurd "Data.Void.absurd"

==> Changes in v5.md <==
# Changes in v5

This is a crash-course guide to things that have changed between v4 and v5. Please open an issue or PR if you have suggestions about anything that is missing or improvements that can be made!

## Component construction

- There are no longer parent and child specific variations for the component constructors, HTML, and DSL types used when defining a component. All components now use `ComponentHTML` and `HalogenM`.

- There are no longer `lifecycle`-specific variations for component constructors either. That leaves us with a single constructor for components, `mkComponent`.

## Component eval

- Previously a component's query algebra defined everything a component could do. This is now split into "actions" and queries.

- Actions are internal to the component (they do not appear in the `Component` type signature), and are of kind `Type` rather than `Type -> Type`. Since actions can only be raised internally there is no need to parameterise them the way queries are, since there is no possibility of an action returning a value.

  Being "raised internally" means they arise from event listeners in the HTML and from `EventSource`s.

- Queries still exist as a means of a parent component interacting with a child. They are not required to be used however - many components can be self contained and only need actions.

- Previously there was a concept of "action-style" queries that did not receive a return value (as opposed to "request-style" queries). These still exist, but are now termed "tell-style", and are constructed with `H.tell` rather than `H.action` to avoid overloading the "action" terminology.

- Query evaluation can now "fail" without resorting to throwing exceptions. Query eval is now `query a -> HalogenM ... (Maybe a)` rather than `query ~> HalogenM ...`. If the evaluator returns `Nothing` for a query, it will be flattened during the call to `H.query`, and result in `Nothing` - it's indistinguishable from the case where the component being queried does not exist at all.

- The `eval` for a component now deals with an input algebra `HalogenQ`:
  ``` purescript
  eval :: HalogenQ query action input ~> HalogenM state action slots output m
  ```
  `HalogenQ` has constructors for lifecycle, receiver, query, and actions:
  ``` purescript
  data HalogenQ query action input a
    = Initialize a
    | Finalize a
    | Receive input a
    | Action action a
    | Query (Coyoneda query a) (Unit → a)
  ```
  This can be pattern matched on and the cases handled as appropriate, but there is a `mkEval` helper that will probably be more convenient to use in most cases.

- `mkEval` accepts an `EvalSpec` record that looks a bit like the old lifecycle component constructor:
  ``` purescript
  type EvalSpec state query action slots input output m =
    { handleAction :: action -> HalogenM state action slots output m Unit
    , handleQuery :: forall a. query a -> HalogenM state action slots output m (Maybe a)
    , receive :: input -> Maybe action
    , initialize :: Maybe action
    , finalize :: Maybe action
    }
  ```
  There is an "empty" version of this called `defaultEval` that can be used and have the relevant fields overridden to reduce boilerplate:
  ``` purescript
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval (H.defaultEval { handleAction = ?handleAction })
    }
  ```
  If `defaultEval` is used with no overrides the component will do nothing for any action raised internally, and any queries made of it will fail.

- If you want to share some of the behaviour between actions and queries without duplicating constructors and/or implementation, add a constructor like `EvalQuery (Query Unit)` to the component's action type, and then pass the `Query Unit` value to `handleQuery` for that case in `handleAction`.

  It's also possible to add an `EvalAction Action a` to the query type for the component instead, but doing it the other way around is recommended. The action type can be used to hide internal interactions that shouldn't be called externally, but the query is always fully public.

- The `Halt` constructor was removed from `HalogenM`. If a component needs to explode in that way, it should be done by lifting something into the component's `m` instead.

  If `Halt` was being used for an infallible case in a higher order component `eval`, the same effect can be achieved now by returning `Nothing`.

  If this doesn't mean anything to you, don't worry about it! Halting wasn't explained anywhere previously and was used internally for the most part.

## Child component addressing

- The component `HTML` and `DSL` (`HalogenM`) types now have a single type variable, `slots`, that determines all the information necessary for child components.

  Previously this was split across two arguments, one for the query type(s) for child components, and another for the slot value(s). When a component had multiple types of child component, these types got unpleasant to deal with, as they needed nested coproduct or either types to accommodate everything.

  The new `slots` is a row type, using the labels as identifiers for the different child component types, and associating a `H.Slot` value with each label, specifying the query and output message type for the child component, and the type to index the component by.

  For example, an old-style setup might look something like this:

  ``` purescript
  type ChildQuery = Coproduct3 CA.Query CB.Query CC.Query

  type ChildSlot = Either3 Unit Unit Unit

  render :: State -> H.ParentHTML Query ChildQuery ChildSlot m
  render state =
    HH.div_
      [ HH.slot' CP.cp1 unit CA.component unit absurd
      , HH.slot' CP.cp2 unit CB.component unit absurd
      , HH.slot' CP.cp3 unit CC.component unit absurd
      ]
  ```

  Now it'd be expressed as:

  ``` purescript
  type ChildSlots =
    ( a :: H.Slot CA.Query Void Unit
    , b :: H.Slot CB.Query Void Unit
    , c :: H.Slot CC.Query Void Unit
    )

  _a = SProxy :: SProxy "a"
  _b = SProxy :: SProxy "b"
  _c = SProxy :: SProxy "c"

  render :: forall m. State -> H.ComponentHTML Action ChildSlots m
  render state =
    HH.div_
      [ HH.slot _a unit CA.component unit absurd
      , HH.slot _b unit CB.component unit absurd
      , HH.slot _c unit CC.component unit absurd
      ]
  ```

  On the surface of it this might look pretty similar to what was there before, but in practice it is _much_ nicer to deal with! Especially if you're one of the people out there who needed more than 10 types of child component, since we only provided helper types and premade `ChildPath` values up to that.

- With the change to the single `slots` type variable, there is now only one `HH.slot` function for rendering and `HH.query` for querying. Previously there was a non-primed version inteded for components that only had one type of child component, which allowed the `ChildPath` argument to be skipped.

  Now an `SProxy` must always be provided to `HH.slot` or `HH.query`, even if there is only one component to choose from, since it would still need to be defined as a `label :: slot` pair in the `slots` row.

- A pattern that has emerged in our usage of the new setup, is to define a `Slot` type synonym along with each component, filling in the query and message values for `H.Slot` but leaving the last argument unspecified.

  So from the above, the `CA`, `CB`, `CC` modules would each have a definition like:
  ``` purescript
  type Slot = H.Slot Query Void
  ```
  Then when used in a parent component the row type can be simplified:
  ``` purescript
  type ChildSlots =
    ( a :: CA.Slot Unit
    , b :: CB.Slot Unit
    , c :: CC.Slot Unit
    )
  ```
  Leaving the last argument (the slot index value) unspecified allows the parent to decide on a suitable value to use there (`Unit` for if there's only going to be one instance of that type of component, some other type like `Int` or `String` if there are going to be multiple instances).

## Subscriptions, forking, and event sources

- `subscribe` now returns a `SubscriptionId` value that allows a subscription to later be cancelled with `unsubscribe`. Previously subscriptions could only be ended "from the inside", where the event source closes itself.

  It is still possible for a subscription to unsubscribe itself, the `subscribe'` function passes the `SubscriptionId` into a function that returns the `EventSource` so that the `EventSource` can raise an action with the relevant `SubscriptionId`.

- `fork` works similarly, in that it returns a `ForkId` rather than the canceler-function it used to. Forks are now cancelled by passing the `ForkId` to `H.kill`.

  Aditionally, `fork`s are killed when a component is finalized now, unless the `fork` takes place during finalization.

- The `EventSource` API was simplified. An `Emitter` type was added in an attempt to make the types more comprehensible, and the many variations of event source construction helpers were reduced to `affEventSource` and `effEventSource`, which should suffice for all common usages.


## Miscellaneous

- You can now `dispose` of an entire Halogen app via the `DriverIO` record returned from `runUI`. This will remove everything from the DOM and finalize the components. Attempting to `query` the `DriverIO` after this will return `Nothing`.

- The examples have been changed to try and best illustrate the feature they relate to, and just generally tidied up a bit. Some specifics:

  - The `interpret` example now works on a component that is using a `ReaderT` over `Aff` rather than a `Free` monad. `ReaderT` + `Aff` is a very common real world setup for an app's effect monad.

  - The `higher-order-components` example shows a expandable/collapsible container box kind of thing that allows interactions with the inner component when it is expanded.

  - The `todo` example has gone, as it was intended to show a fairly-but-not-entirely trivial example, but had weird conventions that nobody uses. @thomashoneyman's [Real World Halogen](https://github.com/thomashoneyman/purescript-halogen-realworld) is a much better and more comprehensive example of how an app might be structured (although it's out of date now, of course!).

- The `accept` property (for file inputs) didn't have quite the right type before, it accepted a `MediaType`, but really should have allowed a collection of media types and file extensions. The type has been changed to a new `InputAcceptType` monoid to fix this.

- The type variables have been renamed to full words in the component / query / etc. type signatures. Maybe this will help, maybe not - feedback is welcome and appreciated!

==> README.md <==
# The Halogen guide


1. [Introduction](1%20-%20Introduction.md)
2. [Defining a component](2%20-%20Defining%20a%20component.md)
    - [State](2%20-%20Defining%20a%20component.md#state)
    - [Query algebra](2%20-%20Defining%20a%20component.md#query-algebra)
    - [Output messages](2%20-%20Defining%20a%20component.md#output-messages)
    - [Rendering](2%20-%20Defining%20a%20component.md#rendering)
        - [The HTML DSL](2%20-%20Defining%20a%20component.md#the-html-dsl)
    - [Query evaluation](2%20-%20Defining%20a%20component.md#query-evaluation)
        - [`HalogenM`](2%20-%20Defining%20a%20component.md#halogenm)
        - [Evaluating actions](2%20-%20Defining%20a%20component.md#evaluating-actions)
        - [Evaluating requests](2%20-%20Defining%20a%20component.md#evaluating-requests)
    - [Putting it all together](2%20-%20Defining%20a%20component.md#putting-it-all-together)
3. [Handling effects](3%20-%20Handling%20effects.md)
    - [Using `Effect` during `eval`](3%20-%20Handling%20effects.md#using-effect-during-eval)
    - [Using `Aff` during `eval`](3%20-%20Handling%20effects.md#using-aff-during-eval)
    - [Mixing `Effect` and `Aff`](3%20-%20Handling%20effects.md#mixing-effect-and-aff)
4. [Running a component](4%20-%20Running%20a%20component.md)
    - [`runUI`](4%20-%20Running%20a%20component.md#runui)
    - [`Aff`-based utility functions](4%20-%20Running%20a%20component.md#aff-based-utility-functions)
    - [Output and subscribers](4%20-%20Running%20a%20component.md#output-and-subscribers)
5. [Parent and child components](5%20-%20Parent%20and%20child%20components.md)
    - [Slot address](5%20-%20Parent%20and%20child%20components.md#slot-address)
    - [Rendering](5%20-%20Parent%20and%20child%20components.md#rendering)
    - [Querying](5%20-%20Parent%20and%20child%20components.md#querying)
    - [Component definition](5%20-%20Parent%20and%20child%20components.md#component-definition)
    - [Input values](5%20-%20Parent%20and%20child%20components.md#input-values)
    - [Multiple types of child component](5%20-%20Parent%20and%20child%20components.md#multiple-types-of-child-component)
        - [Rendering](5%20-%20Parent%20and%20child%20components.md#rendering-1)
        - [Querying](5%20-%20Parent%20and%20child%20components.md#querying-1)
5. Stateless Custom Elements
6. Styling
7. Accessible form behaviours and event handling
8. Component lifecycle hooks*
9. Event sources**
10. Non-`Aff` effect monads**

\* Coming soon...
\** ...ish

**Note:** Please feel free to open issues if you encounter things in the guide that are confusing or need further explanation!
